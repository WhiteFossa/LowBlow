
PowerUnitCoolerController.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000001fa  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  000001fa  0000028e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000003  00800060  00800060  0000028e  2**0
                  ALLOC
  3 .stab         00000a20  00000000  00000000  00000290  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000c69  00000000  00000000  00000cb0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00001919  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000192c  2**2
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
   0:	0e c0       	rjmp	.+28     	; 0x1e <__ctors_end>
   2:	30 c0       	rjmp	.+96     	; 0x64 <__bad_interrupt>
   4:	2f c0       	rjmp	.+94     	; 0x64 <__bad_interrupt>
   6:	2e c0       	rjmp	.+92     	; 0x64 <__bad_interrupt>
   8:	2d c0       	rjmp	.+90     	; 0x64 <__bad_interrupt>
   a:	2d c0       	rjmp	.+90     	; 0x66 <__vector_5>
   c:	2b c0       	rjmp	.+86     	; 0x64 <__bad_interrupt>
   e:	2a c0       	rjmp	.+84     	; 0x64 <__bad_interrupt>
  10:	29 c0       	rjmp	.+82     	; 0x64 <__bad_interrupt>
  12:	28 c0       	rjmp	.+80     	; 0x64 <__bad_interrupt>
  14:	27 c0       	rjmp	.+78     	; 0x64 <__bad_interrupt>
  16:	26 c0       	rjmp	.+76     	; 0x64 <__bad_interrupt>
  18:	25 c0       	rjmp	.+74     	; 0x64 <__bad_interrupt>
  1a:	24 c0       	rjmp	.+72     	; 0x64 <__bad_interrupt>
  1c:	23 c0       	rjmp	.+70     	; 0x64 <__bad_interrupt>

0000001e <__ctors_end>:
  1e:	11 24       	eor	r1, r1
  20:	1f be       	out	0x3f, r1	; 63
  22:	cf ed       	ldi	r28, 0xDF	; 223
  24:	cd bf       	out	0x3d, r28	; 61

00000026 <hal_early_init>:
/** Very early initialization stage. Here we have to disable interrupts ad set-up watchdog to avoid reset during
 * initialization.
 */
void hal_early_init(void)
{
	cli(); /* Disabling interrupts */
  26:	f8 94       	cli
				"out __SREG__,__tmp_reg__" "\n\t"
				"out %0, %2" "\n \t"
				: /* no outputs */
				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
  28:	87 e0       	ldi	r24, 0x07	; 7
  2a:	90 e0       	ldi	r25, 0x00	; 0
  2c:	88 70       	andi	r24, 0x08	; 8
  2e:	99 27       	eor	r25, r25
  30:	89 2b       	or	r24, r25
  32:	11 f0       	breq	.+4      	; 0x38 <hal_early_init+0x12>
  34:	88 e2       	ldi	r24, 0x28	; 40
  36:	01 c0       	rjmp	.+2      	; 0x3a <hal_early_init+0x14>
  38:	88 e0       	ldi	r24, 0x08	; 8
  3a:	97 e0       	ldi	r25, 0x07	; 7
  3c:	97 70       	andi	r25, 0x07	; 7
  3e:	89 2b       	or	r24, r25
  40:	98 2f       	mov	r25, r24
__attribute__ ((__always_inline__))
void wdt_enable (const uint8_t value)
{
	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
	{
		__asm__ __volatile__ (
  42:	88 e1       	ldi	r24, 0x18	; 24
  44:	0f b6       	in	r0, 0x3f	; 63
  46:	f8 94       	cli
  48:	a8 95       	wdr
  4a:	81 bd       	out	0x21, r24	; 33
  4c:	0f be       	out	0x3f, r0	; 63
  4e:	91 bd       	out	0x21, r25	; 33

00000050 <__do_clear_bss>:

	wdt_enable(HAL_WDT_INTERVAL); /* Setting up watchdog timer */
}
  50:	20 e0       	ldi	r18, 0x00	; 0
  52:	a0 e6       	ldi	r26, 0x60	; 96
  54:	b0 e0       	ldi	r27, 0x00	; 0
  56:	01 c0       	rjmp	.+2      	; 0x5a <.do_clear_bss_start>

00000058 <.do_clear_bss_loop>:
  58:	1d 92       	st	X+, r1

0000005a <.do_clear_bss_start>:
  5a:	a3 36       	cpi	r26, 0x63	; 99
  5c:	b2 07       	cpc	r27, r18
  5e:	e1 f7       	brne	.-8      	; 0x58 <.do_clear_bss_loop>
  60:	ad d0       	rcall	.+346    	; 0x1bc <main>
  62:	c9 c0       	rjmp	.+402    	; 0x1f6 <_exit>

00000064 <__bad_interrupt>:
  64:	cd cf       	rjmp	.-102    	; 0x0 <__vectors>

00000066 <__vector_5>:
/**
 *  Timer1 overflow. With 16384 prescaler and 8MHz clock it occurs
 *  ~488 times per second
 */
ISR(TIM0_OVF_vect)
{
  66:	1f 92       	push	r1
  68:	0f 92       	push	r0
  6a:	00 90 5f 00 	lds	r0, 0x005F
  6e:	0f 92       	push	r0
  70:	11 24       	eor	r1, r1
  72:	2f 93       	push	r18
  74:	3f 93       	push	r19
  76:	4f 93       	push	r20
  78:	5f 93       	push	r21
  7a:	6f 93       	push	r22
  7c:	7f 93       	push	r23
  7e:	8f 93       	push	r24
  80:	9f 93       	push	r25
  82:	af 93       	push	r26
  84:	bf 93       	push	r27
  86:	ef 93       	push	r30
  88:	ff 93       	push	r31
  8a:	cf 93       	push	r28
  8c:	df 93       	push	r29
  8e:	cd b7       	in	r28, 0x3d	; 61
  90:	dd 27       	eor	r29, r29
	/* Processing seconds ticks */
	hal_timer1_overflows_number --;
  92:	80 91 61 00 	lds	r24, 0x0061
  96:	90 91 62 00 	lds	r25, 0x0062
  9a:	01 97       	sbiw	r24, 0x01	; 1
  9c:	90 93 62 00 	sts	0x0062, r25
  a0:	80 93 61 00 	sts	0x0061, r24

	if (0 == hal_timer1_overflows_number)
  a4:	80 91 61 00 	lds	r24, 0x0061
  a8:	90 91 62 00 	lds	r25, 0x0062
  ac:	89 2b       	or	r24, r25
  ae:	09 f4       	brne	.+2      	; 0xb2 <__vector_5+0x4c>
	{
		hal_second_tick();
  b0:	14 d0       	rcall	.+40     	; 0xda <hal_second_tick>
	}
}
  b2:	df 91       	pop	r29
  b4:	cf 91       	pop	r28
  b6:	ff 91       	pop	r31
  b8:	ef 91       	pop	r30
  ba:	bf 91       	pop	r27
  bc:	af 91       	pop	r26
  be:	9f 91       	pop	r25
  c0:	8f 91       	pop	r24
  c2:	7f 91       	pop	r23
  c4:	6f 91       	pop	r22
  c6:	5f 91       	pop	r21
  c8:	4f 91       	pop	r20
  ca:	3f 91       	pop	r19
  cc:	2f 91       	pop	r18
  ce:	0f 90       	pop	r0
  d0:	00 92 5f 00 	sts	0x005F, r0
  d4:	0f 90       	pop	r0
  d6:	1f 90       	pop	r1
  d8:	18 95       	reti

000000da <hal_second_tick>:

/**
 * Gets called every second
 */
void hal_second_tick()
{
  da:	cf 93       	push	r28
  dc:	df 93       	push	r29
  de:	cd b7       	in	r28, 0x3d	; 61
  e0:	dd 27       	eor	r29, r29
	hal_timer1_overflows_number = HAL_TIMER1_OVERFLOWS_PER_SECOND; /* Reload Timer1 overflows counter */
  e2:	87 ee       	ldi	r24, 0xE7	; 231
  e4:	91 e0       	ldi	r25, 0x01	; 1
  e6:	90 93 62 00 	sts	0x0062, r25
  ea:	80 93 61 00 	sts	0x0061, r24

	/* For mn_seconds_delay() */
	if (mn_seconds_delay_counter > 0x00U)
  ee:	80 91 60 00 	lds	r24, 0x0060
  f2:	88 23       	and	r24, r24
  f4:	29 f0       	breq	.+10     	; 0x100 <__stack+0x21>
	{
		mn_seconds_delay_counter --;
  f6:	80 91 60 00 	lds	r24, 0x0060
  fa:	81 50       	subi	r24, 0x01	; 1
  fc:	80 93 60 00 	sts	0x0060, r24
	}
}
 100:	df 91       	pop	r29
 102:	cf 91       	pop	r28
 104:	08 95       	ret

00000106 <hal_init>:

/**
 * Hardware initialization function. Call it before any other functions.
 */
void hal_init()
{
 106:	cf 93       	push	r28
 108:	df 93       	push	r29
 10a:	cd b7       	in	r28, 0x3d	; 61
 10c:	dd 27       	eor	r29, r29
	/* Setting ports directions */
	DDRB = HAL_PORTB_DIR;
 10e:	87 e3       	ldi	r24, 0x37	; 55
 110:	90 e0       	ldi	r25, 0x00	; 0
 112:	21 e0       	ldi	r18, 0x01	; 1
 114:	fc 01       	movw	r30, r24
 116:	20 83       	st	Z, r18

	/* Starting cooler (precaution against wrong code) */
	PORTB = _BV(HAL_COOLER_PIN);
 118:	88 e3       	ldi	r24, 0x38	; 56
 11a:	90 e0       	ldi	r25, 0x00	; 0
 11c:	21 e0       	ldi	r18, 0x01	; 1
 11e:	fc 01       	movw	r30, r24
 120:	20 83       	st	Z, r18


	/* Setting up Timer0 (PWM source)
	 * Prescaler 1, phase-correct PWM, non-inverting OC0A output */
	TCCR0A = _BV(COM0A1) | _BV(WGM00);
 122:	8a e4       	ldi	r24, 0x4A	; 74
 124:	90 e0       	ldi	r25, 0x00	; 0
 126:	21 e8       	ldi	r18, 0x81	; 129
 128:	fc 01       	movw	r30, r24
 12a:	20 83       	st	Z, r18
	TCCR0B = _BV(CS00) | _BV(CS02);
 12c:	83 e5       	ldi	r24, 0x53	; 83
 12e:	90 e0       	ldi	r25, 0x00	; 0
 130:	25 e0       	ldi	r18, 0x05	; 5
 132:	fc 01       	movw	r30, r24
 134:	20 83       	st	Z, r18

	/* Setting up Timer1 (time source)
	 * Prescaler 16384, interrupt on overflow */
	TCCR1 = _BV(CS10) | _BV(CS11) | _BV(CS12) | _BV(CS13);
 136:	80 e5       	ldi	r24, 0x50	; 80
 138:	90 e0       	ldi	r25, 0x00	; 0
 13a:	2f e0       	ldi	r18, 0x0F	; 15
 13c:	fc 01       	movw	r30, r24
 13e:	20 83       	st	Z, r18
	GTCCR |= _BV(PSR1); /* Resetting prescaler */
 140:	8c e4       	ldi	r24, 0x4C	; 76
 142:	90 e0       	ldi	r25, 0x00	; 0
 144:	2c e4       	ldi	r18, 0x4C	; 76
 146:	30 e0       	ldi	r19, 0x00	; 0
 148:	f9 01       	movw	r30, r18
 14a:	20 81       	ld	r18, Z
 14c:	22 60       	ori	r18, 0x02	; 2
 14e:	fc 01       	movw	r30, r24
 150:	20 83       	st	Z, r18
	TCNT1 = 0x00; /* And timer too */
 152:	8f e4       	ldi	r24, 0x4F	; 79
 154:	90 e0       	ldi	r25, 0x00	; 0
 156:	fc 01       	movw	r30, r24
 158:	10 82       	st	Z, r1

	/* We need to initialize this variable, otherwise first second tick may occur too late*/
	hal_timer1_overflows_number = HAL_TIMER1_OVERFLOWS_PER_SECOND;
 15a:	87 ee       	ldi	r24, 0xE7	; 231
 15c:	91 e0       	ldi	r25, 0x01	; 1
 15e:	90 93 62 00 	sts	0x0062, r25
 162:	80 93 61 00 	sts	0x0061, r24

	TIMSK = _BV(TOIE1); /* Overflow interrupt */
 166:	89 e5       	ldi	r24, 0x59	; 89
 168:	90 e0       	ldi	r25, 0x00	; 0
 16a:	24 e0       	ldi	r18, 0x04	; 4
 16c:	fc 01       	movw	r30, r24
 16e:	20 83       	st	Z, r18
//
//	/* Disabling digital inputs on ADC channels being used */
//	DIDR0 = _BV(HAL_ADC_CHAN_NB_DIDR) | _BV(HAL_ADC_CHAN_GPU_DIDR) | _BV(HAL_ADC_CHAN_CPU_DIDR);
//
//
	sei(); /* Enabling interrupts, ready to go*/
 170:	78 94       	sei
}
 172:	df 91       	pop	r29
 174:	cf 91       	pop	r28
 176:	08 95       	ret

00000178 <hal_set_cooler_duty_cycle>:

/** Set PWM duty cycle. If value > HAL_MAX_DUTY_CYCLE then set to HAL_MAX_DUTY_CYCLE.
 * If value < HAL_MIN_DUTY_CYCLE then set it to HAL_MIN_DUTY_CYCLE
 */
void hal_set_cooler_duty_cycle(int16_t cycle)
{
 178:	cf 93       	push	r28
 17a:	df 93       	push	r29
 17c:	00 d0       	rcall	.+0      	; 0x17e <hal_set_cooler_duty_cycle+0x6>
 17e:	cd b7       	in	r28, 0x3d	; 61
 180:	dd 27       	eor	r29, r29
 182:	9a 83       	std	Y+2, r25	; 0x02
 184:	89 83       	std	Y+1, r24	; 0x01
	if (cycle > HAL_MAX_DUTY_CYCLE)
 186:	89 81       	ldd	r24, Y+1	; 0x01
 188:	9a 81       	ldd	r25, Y+2	; 0x02
 18a:	8f 3f       	cpi	r24, 0xFF	; 255
 18c:	91 05       	cpc	r25, r1
 18e:	31 f0       	breq	.+12     	; 0x19c <hal_set_cooler_duty_cycle+0x24>
 190:	2c f0       	brlt	.+10     	; 0x19c <hal_set_cooler_duty_cycle+0x24>
	{
		cycle = HAL_MAX_DUTY_CYCLE;
 192:	8f ef       	ldi	r24, 0xFF	; 255
 194:	90 e0       	ldi	r25, 0x00	; 0
 196:	9a 83       	std	Y+2, r25	; 0x02
 198:	89 83       	std	Y+1, r24	; 0x01
 19a:	06 c0       	rjmp	.+12     	; 0x1a8 <hal_set_cooler_duty_cycle+0x30>
	}
	else if (cycle < HAL_MIN_DUTY_CYCLE)
 19c:	89 81       	ldd	r24, Y+1	; 0x01
 19e:	9a 81       	ldd	r25, Y+2	; 0x02
 1a0:	99 23       	and	r25, r25
 1a2:	14 f4       	brge	.+4      	; 0x1a8 <hal_set_cooler_duty_cycle+0x30>
	{
		cycle = HAL_MIN_DUTY_CYCLE;
 1a4:	1a 82       	std	Y+2, r1	; 0x02
 1a6:	19 82       	std	Y+1, r1	; 0x01
	}

	OCR0A = (uint8_t)cycle;
 1a8:	89 e4       	ldi	r24, 0x49	; 73
 1aa:	90 e0       	ldi	r25, 0x00	; 0
 1ac:	29 81       	ldd	r18, Y+1	; 0x01
 1ae:	fc 01       	movw	r30, r24
 1b0:	20 83       	st	Z, r18
}
 1b2:	ce 5f       	subi	r28, 0xFE	; 254
 1b4:	cd bf       	out	0x3d, r28	; 61
 1b6:	df 91       	pop	r29
 1b8:	cf 91       	pop	r28
 1ba:	08 95       	ret

000001bc <main>:

/**
 * Entry point
 */
void main()
{
 1bc:	cf 93       	push	r28
 1be:	df 93       	push	r29
 1c0:	cd b7       	in	r28, 0x3d	; 61
 1c2:	dd 27       	eor	r29, r29
	/* Initialize hardware */
	hal_init();
 1c4:	a0 df       	rcall	.-192    	; 0x106 <hal_init>

	hal_set_cooler_duty_cycle(0x20);
 1c6:	80 e2       	ldi	r24, 0x20	; 32
 1c8:	90 e0       	ldi	r25, 0x00	; 0
 1ca:	d6 df       	rcall	.-84     	; 0x178 <hal_set_cooler_duty_cycle>

	while(1)
	{
		wdt_reset();
 1cc:	a8 95       	wdr
	}
 1ce:	fe cf       	rjmp	.-4      	; 0x1cc <main+0x10>

000001d0 <mn_seconds_delay>:

/**
 * Function waits given number of seconds.
 */
void mn_seconds_delay(uint8_t num_of_seconds)
{
 1d0:	cf 93       	push	r28
 1d2:	df 93       	push	r29
 1d4:	1f 92       	push	r1
 1d6:	cd b7       	in	r28, 0x3d	; 61
 1d8:	dd 27       	eor	r29, r29
 1da:	89 83       	std	Y+1, r24	; 0x01
	mn_seconds_delay_counter = num_of_seconds;
 1dc:	89 81       	ldd	r24, Y+1	; 0x01
 1de:	80 93 60 00 	sts	0x0060, r24
	while(mn_seconds_delay_counter > 0)
 1e2:	01 c0       	rjmp	.+2      	; 0x1e6 <mn_seconds_delay+0x16>
	{
		wdt_reset();
 1e4:	a8 95       	wdr
 * Function waits given number of seconds.
 */
void mn_seconds_delay(uint8_t num_of_seconds)
{
	mn_seconds_delay_counter = num_of_seconds;
	while(mn_seconds_delay_counter > 0)
 1e6:	80 91 60 00 	lds	r24, 0x0060
 1ea:	88 23       	and	r24, r24
 1ec:	d9 f7       	brne	.-10     	; 0x1e4 <mn_seconds_delay+0x14>
	{
		wdt_reset();
	}
}
 1ee:	0f 90       	pop	r0
 1f0:	df 91       	pop	r29
 1f2:	cf 91       	pop	r28
 1f4:	08 95       	ret

000001f6 <_exit>:
 1f6:	f8 94       	cli

000001f8 <__stop_program>:
 1f8:	ff cf       	rjmp	.-2      	; 0x1f8 <__stop_program>
